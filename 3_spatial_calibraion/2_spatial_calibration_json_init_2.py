import os
import numpy as np
from PIL import Image
import json
from scipy.interpolate import interp1d

# === USER INPUTS ===
# Input folder containing your radiometrically calibrated images
input_folder = r'C:\Users\bss10\OneDrive\Desktop\camera_env\aquired_images\calibrated radiometric'
# Output folder where spatially calibrated images will be saved
output_folder = r'C:\Users\bss10\OneDrive\Desktop\camera_env\aquired_images\calibrated_spatial'

# Ensure the output folder exists
os.makedirs(output_folder, exist_ok=True)

# Path to the file containing your spatial calibration coefficients (from previous step)
# This file should have been generated by the spatial calibration script
spatial_coeffs_file = 'spatial_calibration_coeffs.json'

# --- Load spatial calibration coefficients ---
try:
    with open(spatial_coeffs_file, 'r') as f:
        coeffs = json.load(f)
    pixel_size = coeffs['pixel_size_cm_per_pixel']
    offset = coeffs['offset_cm']
    print(f"Loaded spatial calibration coefficients: pixel_size={pixel_size:.4f} cm/pixel, offset={offset:.4f} cm")
except FileNotFoundError:
    print(f"Error: Spatial calibration coefficients file '{spatial_coeffs_file}' not found.")
    print("Please ensure you have run the spatial calibration script first to generate this file.")
    exit() # Exit if coefficients are not found

# --- Function to map pixel index to real-world cm ---
def pixel_to_cm(pixel_index):
    return pixel_size * pixel_index + offset

# --- Batch process all images in the input folder ---
print(f"\nStarting batch spatial calibration for images in: {input_folder}")
print(f"Results will be saved to: {output_folder}")

processed_count = 0
for filename in os.listdir(input_folder):
    # Process common image file types
    if filename.lower().endswith(('.jpg', '.tif', '.tiff', '.png')):
        img_path = os.path.join(input_folder, filename)
        
        try:
            with Image.open(img_path) as img_pil:
                img_pil = img_pil.convert('L')  # Ensure grayscale (assuming calibrated images are grayscale)
                img_np = np.array(img_pil, dtype=np.float32)

            # Get image dimensions
            img_height, img_width = img_np.shape

            # Prepare new x-axis in cm (real-world) for interpolation
            pixel_indices = np.arange(img_width)
            real_world_cm = pixel_to_cm(pixel_indices)

            # Define the desired real-world grid for the output image
            # Here, we create a grid with a fixed resolution (e.g., 0.1 cm/pixel)
            # You can adjust 0.1 based on desired output resolution
            cm_min = real_world_cm[0]
            cm_max = real_world_cm[-1]
            cm_grid = np.arange(cm_min, cm_max, 0.1) # New resolution of 0.1 cm/pixel
            
            # Initialize array for the spatially calibrated image
            img_spatial = np.zeros((img_height, len(cm_grid)), dtype=np.float32)

            # Interpolate each row to the new real-world cm grid
            for i in range(img_height):
                # interp1d creates an interpolation function for each row
                # 'bounds_error=False' prevents errors if extrapolation is needed
                # 'fill_value=0' fills out-of-bounds with black (you might choose a different value)
                interp_func = interp1d(real_world_cm, img_np[i, :], bounds_error=False, fill_value=0)
                img_spatial[i, :] = interp_func(cm_grid)

            # Convert to uint8 (0-255) for saving as a standard image file
            # Clip values to ensure they are within the valid 0-255 range
            img_spatial_uint8 = np.clip(img_spatial, 0, 255).astype(np.uint8)
            
            # Save the spatially calibrated image
            out_path = os.path.join(output_folder, filename)
            Image.fromarray(img_spatial_uint8).save(out_path)
            
            print(f"Spatially calibrated and saved: {filename}")
            processed_count += 1

        except Exception as e:
            print(f"Error processing {filename}: {e}")

print(f"\nBatch spatial calibration complete. Processed {processed_count} images.")
